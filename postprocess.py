import math
import random

import numpy as np
from PIL import Image as im

import utils


def write2canvas(imgs, spaces, indents, imgs_per_line, ht_in=0, wd_in=0, space_in=20, indent_in=80):
    """Takes in all the images generated and writes them all in blank canvases
    in their correct positions as in the document. One canvas is equivalent to one page
    in the document. The function returns a list of canvas whose size is equal to the
    no. of pages in the document.

    Args:
        imgs (List[np.array[np.uint8]]): Images generated by the generator
        spaces (dict[set[int]]): Position of the spaces in each line.
        indents (dict[set[int]]): Position of the indents in each line.
        imgs_per_line (dict[set[int]]): Sum of images, spaces and indents in each line.
        ht_in (int): Top margin.
        wd_in (int): Left margin.
        space_in (int): Length of space preferably 20.
        indent_in (int): Length of indents preferably 4*space_in.
    Returns:
        out (List[np.array[np.uint8]]): Array of images equivalent to the pages in the document.
    """
    w, h = 2500, 2700  # Setting page size
    data = np.zeros((h, w), dtype=np.uint8)  # Creating np array of zeros of size h*w
    data[0:h, 0:w] = 255  # Setting each value to RGB white value

    offset = 0, 0
    pages = math.ceil(len(imgs_per_line) / 30)  # Finding no. of pages

    out = []
    img = iter(imgs)  # Iterator for images of all the generated images of words
    offset_w, offset_h = wd_in, ht_in  # Setting starting position of paste the images

    for page in range(pages):
        line = 0
        canvas = im.fromarray(
            data
        )  # Creating new PIL image canvas to overwrite the generated images on it
        while offset_h < h:
            no_of_words = imgs_per_line[line]
            sdct = spaces[line]  # Extracting the space set for the current line
            idct = indents[line]  # Extracting the indent set for the current line

            for count in range(no_of_words):
                if count in sdct:  # Checking if space is required
                    offset_w += space_in + random.randint(-5, 5)
                elif count in idct:  # Checking if indent is required
                    offset_w += indent_in + random.randint(-10, 10)
                else:
                    st = next(img)  # Storing next image in a variable
                    st = utils.resize_and_threshold(st, 127, 255)
                    st = im.fromarray(st)
                    st_w, st_h = st.size  # Getting the image size
                    rand_offh = offset_h + random.randint(-5, 5)
                    offset = (offset_w, rand_offh)  # Set the pasting position for the new image
                    canvas.paste(st, offset)  # Overwrite the generated image over the canvas
                    offset_w = offset_w + st_w  # Update the offset width

            offset_h = offset_h + 90  # Update the offset height
            offset_w = wd_in + random.randint(0, 7)
            line = line + 1  # Update the line no.
        # canvas.save('page'+str(page)+'.png')
        out.append(np.array(canvas))  # Append the canvas in a np array
    return out


def crop_images(imgs):
    """Removes trailing whitespaces from images.

    Args:
        imgs (List[np.array[np.uint8]]): A list of grayscale images as 2D np arrays.

    Returns:
        imgs (List[np.array[np.uint8]]): A list of grayscale images as 2D np arrays
            without trailing whitespaces.
    """
    for idx, img in enumerate(imgs):
        w = img.shape[1] - 1
        sums = np.sum(img, axis=0)
        for i in range(w, -1, -1):
            if sums[i] < 16320:
                img = img[:, : i + 1]
                break
        imgs[idx] = img
    return imgs


def imgs_to_pdf(imgs, id):
    """Converts the page images to pdf.

    Args:
        imgs (List[np.array[np.uint8]]):
        id (string): An identifier for the run, used as the name for a temp directory.
    """
    new_imgs = []
    for i in imgs:
        new_imgs.append(
            im.fromarray(i).convert("RGB")
        )  # converting each array to PIL Image objects

    new_imgs[0].save(id + "/out.pdf", save_all=True, append_images=new_imgs[1:])


def postprocess_images(imgs, spaces, indents, imgs_per_line, id):
    """Converts the imgs to a pdf file.

    Args:
        imgs (List[np.array]): An np.array of imgs of words in handwritten form.
        spaces (dict[set[int]]): A dict of sets of ints containing positions of spaces in each line.
        indents (dict[set[int]]): A dict of sets of ints containing the positions of indents in
            each line.
        imgs_per_line (dict[int]): A dict of ints containing number of images to put in each line.
        id (string): An identifier for the run, used as the name for a temp directory.
    """
    # removing trailing whitespaces.
    imgs = crop_images(imgs)
    # making pages out of the images.
    pages = write2canvas(imgs, spaces, indents, imgs_per_line)
    # saving the pages as a pdf, probably could've done it here itself.
    imgs_to_pdf(pages, id)
